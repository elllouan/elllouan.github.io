<!DOCTYPE html>

<html lang ="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- make sure that the content fit the device on which we open -->
        <title> Current projects </title>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Audiowide|Sofia|Trirong|Arial|Open+Sans">
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <script src="js/script.js"></script>
        <script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
        <link rel="stylesheet" href="generic-patterns/css/horizontalmenu.css">
        <link rel="stylesheet" href="generic-patterns/css/footer.css">
        <link rel="stylesheet" href="generic-patterns/css/main.css">
        <link rel="stylesheet" href="css/currentprojects.css">
    </head>

    <!-- Within de web page -->
    <body>
        <div id="horizontalmenu"></div>
        
        <section class="main-container">

            <section class="accordion-current-projects">

                <div class="academic-projects">
                    <h2 class="title">Current academic projects</h2>

                    <div class="current-project"> <div class="label"> <h2>NXP OS project</h2> </div>
                        <div class="content">
                                <p>In this project, we program an OS aimed at the Cortex-M33 processor. The purpose here is to understand how an OS works, what is a the difference between the kernel and the user.
                                    We want to be able to understand what happens in the background when we make a syscall.
                                    Here, I will only provide a brief overview about this project. However, you can find a more comprehensive view of it <a href="os_enib_project.html">there</a>.
                                </p>
                                <p>This project consists of several steps:</p>
                                <div class="frame-highlight">
                                    <ol>
                                        <li>Understanding of how a syscall works;</li>
                                        <li>Creating a task (thread) and testing task commutation;</li>
                                        <li>Implementing our own semaphore and mutex;</li>
                                        <li>Implementing the delay feature;</li>
                                        <li>Terminating a task;</li>
                                        <li>Implementing basic features with peripherals: RGB led, button;</li>
                                        <li>Programming more advanced functionalities: UART, etc.</li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="current-project"> <div class="label"> <h2>Robot project</h2> </div>
                        <div class="content">
                            <hr>
                            <div> <h3>Introduction</h3>
                                <p>In this project, our goal is to remotely control a rolling robot by implementing multi-tasking and control command.</p>
                            </div>

                            <hr>
                            <div> <h3>Motor control</h3>
                                <p>Our first goal is to control the motors by implementing a PI controller.

                                </p>
                                <div class="frame-highlight">
                                    <ol>
                                        <li>Determining the system that we aim to control</li>
                                        <li>Tuning the PI factors accordingly</li>
                                        <li>Implementing the PI controller in a task</li>
                                    </ol>
                                </div>

                                <div> <h4>The system</h4>
                                    <p>The motor is controlled in speed. It expects a 20ms-period PWM signal in input that will make it turn at a certain speed. This signal is generated by a STM32 microcontroller.
                                        The motor is idle when the PWM is at 50% duty cycle. To modelize our system (motor), we need to know how it behaves when we apply a variation to the input.
                                        To do so, we generate a PWM of pulse width a 75% duty cycle and we measure the evolution of the motor's speed for the first hundreds samples. We trace the curve in a graph and find out that it is a first order system.
                                        We can deduce the \( \tau \) and \( G \) constants.
                                        \( G \) represents the <span class="bold">variation of the output with regard to the variation of the input</span>. In our case, \(G = \frac{1600}{50} \).
                                        \( \tau \) is the <span class="bold">time constant</span> of the system, where the system is at 63% of its final state. In our case, \(\tau = s(1600 \cdot 0.63) = 8 \cdot Te \).
                                        Now, we extracted the constants of our system, we can start tuning the PI factors.
                                    </p>
                                    <button>Show illustration</button>
                                </div>

                                <div> <h4>PI factors</h4>
                                    <p>In the continuous domain, the PI controller is defined as follows:
                                        \[ PI(s) = K_p \cdot \frac{\omega_i}{s} (1 + \frac{s}{\omega_i}) \]
                                        Since we are aiming to implement a digital PI controller, we need to switch to the discrete domain using the Z-transform. We apply the derivative transform:
                                        \[ s \rightarrow \frac{1-z^{-1}}{T_e} \implies PI(n) = K_p \cdot \frac{T_e}{T_i} \frac{z}{z+1} + K_p = K_p \cdot K_i \cdot \frac{z}{z+1} + K_p \]
                                    </p>
                                    <div> <h5>Phase margin</h5>
                                    </div>
                                </div>

                                <div> <h4>PI implementation</h4>
                                    
                                </div>
                                <img style="width: 30%;" src="images/os_proj/task_motor_robot.PNG" alt="task_motor_robot">
                            </div>
                            <hr>
                            
                            <div> <h3>Multi-threading</h3>
                                <p>In this project, our goal is to remotely control a rolling robot by implementing multi-tasking and control command.</p>
                            </div>
                        </div>
                    </div>

                    <div class="current-project"> <div class="label"> <h2>Calculator project</h2> </div>
                        <div class="content">
                            <hr>
                            <div> <h3>Introduction</h3>
                                <p>In this project, our goal is to develop an embedded scripting calculator on a NXP microcontroller.
                                We have the PC that can communicate with the NXP board over UART. From the PC, we open a serial communication and input math operation commands.
                                These are received by the microcontroller which interprets them.
                                Therefore, we use a C library called <span class="mark">Calc</span> that can be integrated in a microcontroller.
                                This library was developed to perform arithmetic operations using a scripting approach like Matlab. The board has already some of the code
                                implemented in it. This project organises itself around three tasks:</p>
                                <div class="frame-highlight">
                                    <ul>
                                        <li> <span class="mark">Task 1: External communication</span>
                                            <ol style="margin-left: 1rem;">
                                                <li>Handling VT100 (ANSI escape sequences);</li>
                                                <li>Mounting a file system on a SD card;</li>
                                                <li>Executing syscalls on files stored on the SD card.</li>
                                            </ol>
                                        </li>
                                        <li> <span class="mark">Task 2: Multicore system</span>
                                            <ol style="margin-left: 1rem;">
                                                <li>Booting the two cores;</li>
                                                <li>Sharing data between the two cores;</li>
                                                <li>Performing synchronous and asynchronous tasks.</li>
                                            </ol>
                                        </li>
                                        <li> <span class="mark">Task 3: Bringing math further</span>
                                            <ol style="margin-left: 1rem;">
                                                <li>Adding PowerQuad to the system;</li>
                                                <li>Computing the cosine of a function;</li>
                                                <li>Performing advanced math operations like FFT.</li>
                                            </ol>
                                        </li>
                                    </ul>
                                </div>
                            </div>

                            <hr>
                            <div class="project-structure"> <h3>Project structure</h3>
                                <p>The project is aranged this way. The folders which we are mainly interested in are <span class="italic">source, fatfs, lcd, sdmmc</span>.
                                    Folder names are pretty self-explanatory, except for <span class="italic">sdmmc</span> which contains the drivers for the SD card.
                                    I provided a view of the source folder.
                                </p>
                                <div class="intro-img">
                                    <img src="images/project_structure.JPG" alt="proj_struct">
                                    <img src="images/src_structure.JPG" alt="src_struct">
                                    <img src="images/nxp_board.jpg" alt="nxp_board">
                                </div>
                                <p><span class="italic">sysdep.c</span> is the file containing the main function.</p>
                            </div>

                            <hr>
                            <div class="task1"> <h3>Tasks</h3>
                                <p>I was assigned the <span class="mark">first task</span>, so in this section I will explain how I proceeded to complete those.
                                    I mostly worked in the <span class="italic">sysdep.c</span> file.
                                </p>
                                <div class="task1-1"> <h4>1. VT100 code</h4>
                                    <p>Historically, a terminal could only interpret keyboards that would output printing characters. In that matter, the VT100 (or ANSI escape sequences)
                                        were invented so that a terminal could also interpret non-printing characters such as arrow cursors or f keyboards. With this new standard was
                                        introduced brand new features and we could now move the cursor, clear the screen, change the color of the text, etc.
                                        In this project, the terminal on the laptop's end sends characters to the board that are sent back so they can be visualized on the terminal.
                                        This way, when a VT100 characters sequence is sent to the board, we just need to send it back and the terminal will interpret it accordingly.
                                    </p>
                                    <div class="task1-1-img">
                                        <img src="images/sys_waitkey.JPG" alt="vt100">
                                        <img src="images/scan_t.JPG" alt="scan_t">
                                    </div>
                                    <p><span class="italic">sys_wait_key</span> is called by a Calc function. It returns <span class="italic">c</span> and modifies the <span class="italic">scan</span> pointer.
                                        <span class="italic">scan_t</span> is a enum type defined in the Calc header. Here we can see that this function gets the c character and depending on what characters it is we assigned to scan the right value.
                                        In the case of a VT100 sequence, the first character is an escape character (0x1B = 27). Since the function is quite long, I did not screenshot it entierly, though we can see the approach for the first sequences.
                                    </p>
                                </div>
                                <hr>
                                <div class="task1-2"> <h4>2. File system</h4>
                                    <p>We want to be able to load files from the SD card and execute them and to do so, we need to mount a file system on the SD card. We were required to use
                                        the FAT32 file system. The FAT32 file system is a simple file system and is the most commonly used. It is part of the FAT family file system developed by Windows.
                                        A file system allows to arange memory space of a storage device such as an SD card, thereby providing a convenient way to naviguate through the memory, store and access data.
                                        The FAT32 library documentation is available at this <a href="http://elm-chan.org/fsw/ff/00index_e.html">link</a>.
                                    </p>
                                    <div class="task1-2-img">
                                        <img src="images/fs_cd.JPG" alt="fs_cd">
                                        <img src="images/fs_mkdir_rm.JPG" alt="fs_mkdir">
                                    </div>
                                </div>
                                <hr>
                                <div class="task1-3"> <h4>3. Syscalls</h4>
                                    <p>Now that we can access with files stored on a SD card, we would like to be able to interact with them (modifying or executing them).
                                        To do so, we need to implement basic syscalls-like features.
                                        Indeed, the Calc library makes available some commands that are meant for opening, closing, reading and writing files.
                                        My job here was to implement Calc functions using FAT32 functions.
                                    </p>
                                    <div class="task1-3-img">
                                        <img src="images/open_close.JPG" alt="open_close">
                                        <img src="images/read_write.JPG" alt="read_write">
                                    </div>
                                </div>
                                <hr>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="personal-projects"> <h2 class="title">Personal projects</h2>

                    <div class="current-project"> <div class="label"> <h2>Learning AI with tensorflow</h2> </div>
                        <div class="content">
                            <p>My curiosity and genuine desire to learn more about engineering topics caused me to start this new journey of learning the basics of AI.
                                My guide is this freecodecamp <a href="https://www.youtube.com/watch?v=IA3WxTTPXqQ&list=LL&index=2&t=440s" target="_blank">course</a>.
                                My goal with this web page is to try to explain what I learn and writing it with <span class="bold">my own words</span>. Therefore, <span class="bold">does not take this content as a reference</span>,
                                there might be some inaccuracies (or even mistakes). While, this page is more dedicated to a theorical approach (because understanding the theory and math is satisfying but not enough),
                                <a href="ai.html">here</a> can be found a more practical approach, using Google Colab with the python module <span class="bold">Tensorflow</span>.
                            </p>
                            <hr>
                            <div> <h3>Convolution in probability and image processing</h3>
                                First off, I would like to mention this wonderful video of <a href="https://www.youtube.com/watch?v=IaSGqQa5O-M" target="_blank">3Blue1Brown</a>.
                                There I learnt a lot and improve my understanding about the role that convolution plays in probability and image processing.
                                To get started, I will try to summarize quickly what it is explained in this video.
                                
                               <div> <h4>Discrete convolution</h4>
                                    <p>We can start by focusing on the discrete case which (in my opinion) brings the main idea of why we use convolution in probability.
                                        The formula goes \[ (f(n)*g(n))(s) = \sum^{N}_{n=0} f(n) g(s-n) \]
                                        Here \(f(n)\) and \(g(m)\) are functions representing the probability of a random discrete variable.
                                        So if we try to think this through, we can notice that a new variable appeared \(s\) and also we do this weird operation consisting of multiplying \(g(s-n)\) with \(f(n)\).
                                    </p>
                                    <p>Now let's image I want to determine the probability that 2 consecutive and independent events (let's say \( n+m=5 \)) occur.
                                        To be easier, let's consider that \(n\) and \(m\) are variables representing the face of a dice.
                                        We need to consider all possibilities, such as \(n=1\) and \(m=4\), \(n=2\) and \(m=3\) and so on. So we end up adding these probabilities:
                                        \(f(n=1) \times g(m=4) + f(n=2) \times g(m=3) + f(n=3) \times g(m=2) ... \). If we generalize this operation to all other possible combinaisons of events \( n+m=s \),
                                        where \(s\) can take any possible value an event can take (in our case, from 1 to 6).
                                        You may have understood it, \(s\) represents the combinaison of two successive and independent events \(n\) and \(m\). So to get back to the example,
                                        the probability that we get a total of 5 after having thrown the dice twice can be written as follows:
                                        \[ P(5) = \sum^{6}_{n=1} f(n) g(5-n) = f(n=1) \times g(m=4) + f(n=2) \times g(m=3) + ... + f(n=4) \times g(m=1) \]
                                        If we repeat this operation for each value of \(s\), we get a function of \(s\) where the image represents the probability that \(s=n+m\) occurs.
                                    </p>
                                </div>
                                
                                <div> <h4>Continuous convolution</h4>
                                    <p>The formula goes \[ (f(x)*g(x))(s) = \int^{+\infty}_{-\infty} f(x) g(s-x) dx \]
                                        Here \(f(x)\) and \(g(y)\) are functions representing the probability density of a random variable.
                                        The outcome of this convolution operation is a new function \(h(s)\), called the probability density function,
                                        where \(s\) represents the random variable \(X+Y\) and its image represents the probability (density) that \(P_X + P_P\) occurs.
                                        The concept is basically the same, since we are in a contiuous set of random variables,
                                        we just expand the discrete case \(\sum\) to the continuous case \(\int\), which means we consider the area under the curve.
                                    </p>
                                </div>

                            </div>
                            <hr>
                            <div> <h3>Introduction to Machine Learning</h3>
                                <p>After having been through the main functionalities of TensorFlow, this is now the time to implement a concrete example.
                                    I will build a simple machine learning model based on linear regression in order to predict the price of a current car.
                                    For this, I have downloaded this <a href="">csv</a> file, which stores thousand different cars and their features.
                                    The model will predict, using the linear regression method, the likely price of a car given some of its features.
                                </p>
                                
                            </div>
                            <hr>
                            <div> <h3>Neural Network Layers model</h3>
                                <p>A <span class="bold">neural network</span> consists of 3 parts: the <span class="bold">input layer</span>, the
                                    <span class="bold">hidden layer(s)</span> and the <span class="bold">output layer</span>. Now let's expand on each one of them.
                                </p>
                                <div> <h4>Layers</h4>
                                    <h5>Input layer</h5>
                                    <p>The <span class="bold">input layer</span> is the layer that gets our data. It allocates <span class="bold">1 neuron per input argument</span>.
                                        For example, an input argument for an image would be a pixel. <span class="bold">The dimension of the input layer amounts the dimension of the one input argument</span>.
                                        Each neuron of the input layer is connected to all neurons of the next layer, the <span class="bold">hidden layer</span>.
                                    </p>
                                    <h5>Hidden layer</h5>
                                    <p>a <span class="bold">hidden layer</span> has no contact with the outside, unlike the input and output layers. It is the layer that processes the data.
                                        Each neuron of this layer gives a certain <span class="bold">weight</span> \( w_n \) to the input data, with \( n \) the dimension of the input data.
                                        The output of each neuron is the sum of all weighted inputs plus a bias \( b \) and the result is passed through an <span class="bold">activation function</span> (will come back to this later on).
                                        What comes out of each layer of a hidden layer is \( y = \sigma(w_1x_1 + w_2x_2 + ... + w_nx_n + b) \), with \( \sigma \) the activation function and \( y \) of dimension one.
                                        As for the input layer, each neuron of the hidden layer is connected to all neurons of the next layer, which may be another hidden layer or the <span class="bold">output layer</span>. 
                                    </p>
                                    <h5>Output layer</h5>
                                    <p>The <span class="bold">output layer</span> is the last layer of our model and </p>
                                    <p>The graph below depicts an overview of what a NNL look like.</p>
                                    <img src="images/ai/NNL.png" alt="NNL">
                                </div>

                                <div> <h4>Backpropagation</h4>
                                    <p>Though I have still troubles to grasp how this <span class="bold">backpropagation</span> works (it is on working progress haha). I understand
                                        things separately but ... well. I will try to explain what I have understood and also bring up what I am still struggling with.
                                        At each iteration (each time the model is fed with an input data \( X \)), it computes the loss (difference between prediction and truth) after having processed the data according to weights \( w_n \).
                                        For each neuron this would go as follows:
                                        \[ X = (x_1, x_2, x_3, x_4 ... x_n) \rightarrow a_i = \sigma(w_{i1} \cdot x_1+w_{i2} \cdot x_2+w_{i3} \cdot x_3+...+b) \]
                                        with \( a_i \) the output of the neuron \(i^{th}\) of a given layer and \( \sigma \) the activation function.
                                        <div class="frame-highlight">
                                            <p>Already here, I am not sure about the activation function. I have seen several activation functions such as the sigmoid function, the ReLU function, etc.
                                                However I don't fully understand their purpose and why not other functions.
                                            </p>
                                        </div>
                                    </p>

                                    <h5>Loss and cost functions</h5>
                                    <p>Then, after going through all hidden layers, it reaches the output layer, where it computes the <span class="bold">loss function</span>. There exist different loss functions,
                                        such as the <span class="bold">mean squared error</span> (MSE), <span class="bold">absolute error</span> (AE), <span class="bold">Huber</span>, etc. For sake of simplicity, I will only consider the MSE. 
                                        \[ L = \frac{1}{2}(y_{pred}-y_{true})^2 \]
                                    </p>

                                    <h5>Adjusting the weights</h5>
                                    <p>When I will have studied more about the math behind I will try to explain it here. However, I got the concept. The idea is to compute the gradient of the <span class="bold">cost function </span>(batch of data) with respect to the weights and biases of the model.
                                        After each batch of data the model takes the average of each loss function. So let's say our model is fed with batches of 32 inputs, it will compute the cost function as follows:
                                        \[ C = \frac{1}{B} \sum_{i=1}^{B} L_i\]
                                        where \(B\) is the batch size (32 here) and \( L_i \) the loss function of the \(i^{th}\) input of the batch. Then, the model computes how much each weight of the output layer impacts the cost function.
                                    </p>
                                    <div class="frame-highlight">
                                        <p>If a <span class="bold">slight variation</span> of a weight \( w_i \) causes a <span class="bold">significant variation</span> of the cost function, then it means that this weight has a <span class="bold">great</span> impact on <span class="bold">reducing the error</span>.
                                            On the other hand, if a <span class="bold">slight variation</span> of a weight \( w_i \) causes a <span class="bold">slight variation</span> of the cost function, then it means that this weight has a <span class="bold">small</span> impact on reducing the error.
                                            To empower this chacteristics, we use the <span class="bold">gradient</span> \( \nabla \), which is an equivalent of the derivative for multi-arguments functions. As a result, the <span class="bold">weight is modified proportionnaly to the variation it causes in the cost function</span>.
                                        </p>
                                    </div>
                                    <div class="frame-highlight">
                                        <p>To be more accurate, this method is called the <span class="bold">stocastic gradient descent (SGD)</span> which is a statistical approximation of the gradient descent.
                                            This approximation holds because we take the average of the loss function, and not each loss function.
                                            Otherwise, the model would take too much time to compute the gradient of the cost function with respect to each weight and bias.
                                        </p>
                                    </div>
                                    <p>The model will recursively adjust all the weights and biases starting from the output layer and going back to the input layer. We determine the new weights for each data of the output layer as follows:
                                        \[ w_i = w_i - \mu \frac{\delta C(w_i)}{\delta w_i} = w_i - \mu \nabla \cdot \vec{C_{w_i}} \]
                                        where \( \mu \) is the learning rate, \( \nabla \cdot \vec{C_{w_i}} \) the gradient of the cost function with respect to the weight \( w_i \) and \( i \) the index of each input data \( a_i \).
                                        This process is repeated now for the hidden layers. We determine the new weights for each neuron of each layer:
                                        \[ w_{hi} = w_{hi}- \mu \frac{\delta C(w_{hi})}{\delta w_{hi}} \]
                                        where \( h \) is the index of each neuron and \( i \) the index of each input data \( a_i \).
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="current-project"> <div class="label"> <h2>Buidling an OS from Scratch</h2> </div>
                        
                        <div class="content">
                            <p>In this project, I intend to build an OS from scratch. I want to leverage the knowledge I will acquire along the academic OS project to learn more about this topic.
                                Therefore, I started off this new OS journey to program a complete OS from scratch. I will be following the contents and tutos provided by <a href="https://wiki.osdev.org/Main_Page">OSDev.org</a>.
                                Also, I will be picking some information in this <a href="https://www.youtube.com/playlist?list=PLHh55M_Kq4OApWScZyPl5HhgsTJS9MZ6M">Youtube series</a>.
                                I find it to be really interesting to be able to comprehend thoroughly what building an OS really requires, I mean the whole process.
                                As for the academic project, you can find a deeper view of this project on this <a href="os_project.html">page</a>. This will be a much harder task, as I will self-teach myself this topic.
                                This page is not aimed at giving an in-depth view on my project, I just go over the main steps I went through. To see a more detailed version, you can refer to my complete project <a href="os_project.html" target="_blank">description</a>.
                            </p>
                            <p>This project consists of several steps:</p>
                            <div class="frame-highlight">
                                <ol>
                                    <li>Bootstrapping & Cross-Compiler;</li>
                                </ol>
                            </div>
                        </div>
                    </div>

                    <div class="current-project">
                        <div class="label"> <h2>Website & Web server</h2> </div>
                        <div class="content">
                            <p>So far, this small presentation website has been hosting on GitHub servers. I want to expand it so that it becomes like a personal blog and host it on my own web server.
                                This will be a great opportunity to enhance my understanding and skills of network concepts and security. 
                            </p>
                        </div>
                    </div>

                    <div class="current-project">
                        <div class="label"> <h2>Podcast</h2> </div>
                        <div class="content">
                            <p>Tech, environmental issuses, personal reflections, book reviews and experience feedback. (no episode released yet)</p>
                        </div>
                    </div>

                </div>
            </section>
            

        
        </section> <!-- main-container -->

        <div id="footer"></div>

    </body>

</html>


