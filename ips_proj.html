<!DOCTYPE html>

<html lang ="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- make sure that the content fit the device on which we open -->
        <title> Instrumentation Project </title>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Audiowide|Sofia|Trirong|Arial|Open+Sans">
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <script src="js/script.js"></script>
        <link rel="stylesheet" href="generic-patterns/css/main.css">
        <link rel="stylesheet" href="generic-patterns/css/horizontalmenu.css">
        <link rel="stylesheet" href="generic-patterns/css/footer.css">
        <link rel="stylesheet" href="css/ips_proj.css">
    </head>

    <!-- Within de web page -->
    <body>
        <div id="horizontalmenu"></div>
        
        <section class="main-container">

            <h1>Control of the height of a mass</h1>
            <h3 class="page-subtitle">This page describes more throughly the steps of the project and my learning outcomes.</h3>

            <div class="section"> <h2>Structure of the project</h2>
                <div class="sub-section"> <h3>General overview</h3>
                    <p>We are a group of 5 students working on this project. The goal is to control the height of a mass, hooked to a shape memory spring, accordingly to the command done by the user.
                        To do so, we have a flight time sensor that measures the distance between the mass and the ground. This sensor is connected via IÂ²C to the STM32F4 microcontroller.
                        The board implements a PID controller that serves the whole system with a PWM signal. The PWM signal is then amplified by a MOSFET to control the current flowing through the shape memory spring.
                    </p>

                    <div> <h4>Equipment</h4>
                        <p>The basic equipment for this project consisted of:</p>
                        <div class="frame-highlight">
                            <ul>
                                <li>Shape memory spring</li>
                                <li>Mass</li>
                                <li>Gallows</li>
                                <li>Flight time sensor</li>
                                <li>STM32F411RE microcontroller</li>
                            </ul>
                        </div>
                    </div>

                    <div> <h4>Method</h4>
                        <p>We divided this project into multiple steps:</p>
                        <div class="frame-highlight">
                            <ul>
                                <li>Testing and getting familiar the system</li>
                                <li>Implementing basic functionalities on the microcontroller: PWM generation, ADC, Timer, etc.</li>
                                <li>Devising the PCB structure and testing remote parts</li>
                                <li>Elaborating the PCB on Eagle</li>
                                <li>Developing an GUI</li>
                                <li>Figuring out PID parameters</li>
                                <li>Creating a web page to present our project</li>
                            </ul>
                        </div>
                    </div>

                    <div> <h4>Workload repartition</h4>
                        <p>As mentionned above, we are a group of 5 students. Regarding our preferences, we assign ourselves different parts: </p>
                        <div class="frame-highlight">
                            <ul>
                                <li><span class="bold">Julien:</span> worked on the hardware electronics (Eagle) and Gantt digram.</li>
                                <li><span class="bold">Gentilla:</span> worked with Julien (Eagle) and with me for the web page.</li>
                                <li><span class="bold">Titouan:</span> worked on the GUI (Python).</li>
                                <li><span class="bold">Pierre-Nicolas:</span> worked on the software electronics (STM32).</li>
                                <li><span class="bold">Elouan (me):</span> worked on the web page and also on the PID algorithm (STM32).</li>
                            </ul>
                        </div>
                    </div>

                    <div> <h4>Upfront difficulties</h4>
                        <p>The system we aim to serve is a shape memory spring. However, it is very hard to predict the system's behavior because its transfer function changes as the spring
                            temperature increases. Therefore, we will be considering the spring as a black box and we will try to find the best PID parameters by trials and errors.
                        </p>
                    </div>

                    <div> <h4>Schema</h4>
                        <img src="images/ips_proj/Schema.png" alt="">
                    </div>
                </div>
            </div>

            <div class="section"> <h2>PCB</h2>
                <div> <h4>Designing the PCB</h4>
                </div>

                <div> <h4>Current measurement</h4>
                </div>

                <div> <h4>STM32 peripherals</h4>
                </div>

                <div> <h4>Building the PCB with Eagle</h4>
                </div>
            
            </div>
                
            <div class="section"> <h2>PID implementation</h2>
                <p>In control systems, ideally we know (or can figure out by stimulating it) the behavior of the system we aim to control. However here it is slightly different ...</p>
                <div> <h4>Command control</h4>
                    <p>The STM32 microcontroller implements a PID that outputs a <span class="bold">PWM signal</span>. This PWM signal is input to the transistor that is piloted in an <span class="bold">open-closed mode</span>.
                        The duty cycle of this signal directly impacts how <span class="bold">much current flows through the spring</span>. We know (from the teacher) that the spring behaves somehow like a <span class="bold">low-pass filter</span> (in fact, the spring is a black box).
                        Hence, it will only see the <span class="bold">average</span> of the current flowing through it. Then, it is easy to understand that the <span class="bold">wider</span> duty cycle, the <span class="bold">higher</span> the tension (so the current). 
                        It is important to mention that we supply the spring with a 3V source and it takes time to heat up. We have experimented different duty cycle to see how the system behaves.
                        This is aimed at giving us a rough hint about how fast the spring reacts. 
                    </p>
                    <div class="frame-highlight">
                        <p>Our main difficultes lie in the fact that we only have <span class="bold">control on the elevation of the mass</span> and we don't have a <span class="bold">model of the system's behavior</span>.</p>
                    </div>
                </div>

                <div> <h4>PI algorithm</h4>
                    <p>As stated, we can only control the <span class="bold">rise process</span> of the system quite decently (e.g., the spring fold), by <span class="bold">tweaking the duty cycle</span> of the PWM signal, even though we do not know exactly its behavior.
                        However, the fall process depends the surrounding temperature that makes the spring unfold. We have to wait for the spring to cool to have it go down.
                        Thus, we should <span class="bold">avoid overshooting</span> the target height. Eventually, we want a PI that makes the mass reach the target as fast as possible without overshooting it.
                        For a first test, we decided to remove the derivative factor \(K_d\), so we only need to tune the proportional \(K_p\) and integral \(K_i\) factors.
                        The \( K_p \) factor will make the system reach the target faster, while the \( K_i \) factor will correct the error over time. Moreover, we know that:
                        \[ \delta_e \leq \delta_{max} = 100mm \]
                        \[ \delta_e \leq 0 \implies dc=0\% \implies 0V \]
                        \[ \delta_e=\delta_{max} \implies dc=60\% \implies 3V \]
                        We only make the duty cycle vary up to 60% because beyond this value, we noticed that the spring is dramatically less likely to be reversed. Now let's consider the algorithm :
                        \[ u_p = K_p \cdot \delta_e \]
                        \[ u_i = u_i + K_i \cdot u_p \]
                        \[ u_{cmd} = u_p + u_i \]
                        \( \delta_e \) represents the error (in mm) between the <span class="bold">current position and the target position</span>. Every ms, we update the PWM duty cycle using the output variation \( u_{cmd} \).
                        Thus, we need to map the variation \(u_{cmd}\) to a variation of our PWM duty cycle, because that is how we serve our system.
                        It is important to note that what we calculated here is a variation of the command, meaning that it should be in the same order of magnitude as the PWM duty cycle (comprised between 0% and 60%), to avoid saturation.
                        <!-- Therefore, we could map one millimeter for one percent of duty cycle. However, we want to be able to reach the target as fast as possible. So, we will use a linear mapping function
                        I think that our _( K_i \) will be very important. -->
                    </p>
                </div>

                <div> <h4>First conclusions</h4>
                    <p>After having tested different values of \(K_p\) and \(K_i\), results turned out to be unsatisfying.
                        The problem is that the string behaves like a hysterisis: <span class="bold">one threshold to fold but another one to unfold</span>. This is due to the heat accumulation in the spring over time.
                        The <span class="bold">error accumulated</span> over time is <span class="bold">too important</span> to be reversed within few hundred ms.
                        Either, the value of \(K_i\) is <span class="bold">too low</span> and the system does not reach the target fast enough (several minutes), or it is <span class="bold">too high</span> and the system <span class="bold">overshoots</span> the target and keeps oscillating around the target.
                    </p>
                    <div class="frame-highlight">
                        <p>The \(K_i\) factor is noticeable on the oscilloscope. It widens the duty cycle of the PWM signal, so long as the system do not reach its target. That widening effect is proportional to the error.</p>
                    </div>
                </div>

                <div> <h4>PID?</h4>
                    <p>After reflection, we could try to use the \(K_d\) factor to <span class="bold">lower the impact</span> of the \(K_i\) factor, especially during the spring's critical state. The \(K_d\) factor plays a role in <span class="bold">emphasizing sharp changes</span> in the system.
                        This factor could be relevant because we noticed that after a duty cycle threshold value, the spring <span class="bold">skrinks very quickly</span> (i.e., high derivative), which causes the <span class="bold">mass to rise fast</span>.
                        This sharp change in the mass height can be handled by the <span class="bold">derivative factor</span>.
                        However, instead of adding this factor, we can <span class="bold">substract</span> it to the command so that when significant changes occur, the <span class="bold">command is slowed down</span>. Otherwise the spring is <span class="bold">almost idle</span>, resuting in a \(K_d\) factor that is has <span class="bold">no influence</span>.
                        \[ u_p = K_p \cdot \delta_e \]
                        \[ u_i = u_i + K_i \cdot u_p \]
                        \[ u_d = K_d (u_d^{n} - u_d^{n-1}) \]
                        \[ u_{cmd} = u_p + u_i - u_d \]
                        \(u_d\) is the derivative of the command. \(n\) represents the current iteration and \(n-1\) the previous one.
                    </p>
                </div>

                <div> <h4>PID conclusions</h4>
                    <p>Will try this algorithm next wednesday, trying different values of \(K_d\) and see if it is more efficient than the previous one.
                    </p>
                </div>

                <div> <h4>P factor only</h4>
                    <p>We also decided to implement a P controller only, to fix the PI to fix the problem of error accumulation.
                        We decied to implement a simple P controller and then when the mass is on the verge of exceeding the target, we switch "instanteniously" to a lower duty cycle.
                        After some tests, the mass stabilizes quite fast on the target (few seconds) and oscillations are unsignificant.
                    </p>
                    <div class="frame-highlight">
                        <p><span class="bold">Limitations:</span></p>
                        <ol>
                            <li>the PWM signal is fixed to be effective in a lukewarm temperature (~20Â°C) environment. If the environment started to get colder, the PWM would not change because there is no accumulation of error.</li>
                            <li>the PWM switches from 10% to 60% within a short amount of time (sharp tension changes) and this might damage the system and the board faster.</li>
                        </ol>
                    </div>
                </div>

                <div> <h4>Saturation and unstability</h4>
                    <p>We want to make sure that our command does not saturate for too long as it can cause quick changes and in the end may lead to unstability.
                    </p>
                </div>

                <div> <h4>Current loop</h4>
                    <p>We also have to be careful about the current flowing through the spring.
                    </p>
                </div>

            </div>

            <div class="section"> <h2>GUI</h2>
                <div> <h4>Communication</h4>

                </div>

                <div> <h4>Real-time display</h4>

                </div>
            </div>

            <div class="section"> <h2>Conclusion</h2>
                            
            </div>

        </section> <!-- main-container -->

        <div id="footer"></div>

    </body>

</html>