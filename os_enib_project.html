<!DOCTYPE html>

<html lang ="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- make sure that the content fit the device on which we open -->
        <title> OS project </title>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Audiowide|Sofia|Trirong|Arial|Open+Sans">
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <script src="js/script.js"></script>
        <link rel="stylesheet" href="generic-patterns/css/main.css">
        <link rel="stylesheet" href="generic-patterns/css/horizontalmenu.css">
        <link rel="stylesheet" href="generic-patterns/css/footer.css">
        <link rel="stylesheet" href="css/os_project.css">
    </head>

    <!-- Within de web page -->
    <body>
        <div id="horizontalmenu"></div>
        
        <section class="main-container">
            <h1>OS Project</h1>
            <div class="page-subtitle">
                <h3>In this project, my goal is to implement basic OS functionalities, thereby gaining a deeper understanding of its underlying mechanisms.</h3>
            </div>

            <div> <h2>Structure of the project</h2>
                <p>We worked with the platform MCUXpresso IDE,  and will build targets for the Cortex-M33 CPU. 
                    The project is divided into several steps:
                </p>
                <div class="frame-highlight" style="display: flex; flex-direction: row;">
                    <ol style="margin: auto 1.5rem;">
                        <a href="#syscalls"><li>Understanding of how syscalls work;</li></a>
                        <a href="#tasks"><li>Creating a task (thread) and testing task commutation;</li></a>
                        <a href="#semaphores"><li>Implementing our own semaphore and mutex;</li></a>
                        <a href=""><li>Implementing the delay feature;</li></a>
                        <a href=""><li>Terminating a task;</li></a>
                        <a href=""><li>Implementing basic features with peripherals: RGB led, button;</li></a>
                        <a href=""><li>Programming more advanced functionalities: UART, etc.</li></a>
                    </ol>
                    <img style="width: 40%;" src="images/os_proj/structure_proj.svg" alt="structure_proj">
                </div>
                
            </div>

            <div> <h2 id="syscalls">1. Syscalls</h2>
                <p>To understand syscalls, we must understand the difference between the <span class="bold">user session and the kernel</span>. Basically, when we run any application or software
                    on our computer, we are located in the user session, meaning that we have restricted privilieges. But most of the time, the program (software) needs to perform
                    or have access to some stuffs that require the use of the kernel. The application would then issue a <span class="bold">syscall</span> to request the OS for higher services.
                    Hence, the OS comes <span class="bold">between the user-level program (session) and the hardware</span>. The <span class="bold">kernel</span> is the low-level part of the OS that has access to all the resources of the computer.
                    It handles essential resources such as <span class="bold">process management (priorities, round-robin), memory management (data allocation), device-driver management and syscall handling</span>.
                    It coordinates all the <a href="#tasks">tasks</a> by deciding which one is the most urgent and providing resources accordingly. Having access to the kernel means having the highest privileges.
                    In Ubuntu, when we issue the <span class="bold">sudo</span> command, we are asking for kernel privileges.
                </p>

                <div> <h3>1.1 Handler/Thread modes</h3>
                    <p>By default, when we run a task (or thread), we are in a <span class="bold">Unprivileged Thread</span> mode.
                        To trigger a syscall, we need to call a function implemented in the OS library (like os_alloc). This function will then
                        call the <span class="bold">SVC (SuperVisor Call)</span> followed by a number, which refers to the type of syscall requested (1 for os_alloc).
                        <div class="frame-highlight">
                            <p> The instruction <span class="bold">__ASM volatile("...")</span> injects assembly code. It is necessary to use assembly code to program a syscall, this cannot be done with C code.
                                Calling the <span class="bold">svc</span> assembly instruction will trigger an exception. Therefore, it will involve the
                                <span class="bold">NVIC</span>, which will branch the PC to the <span class="bold">SVC_Handler</span> function in the OS kernel (svc.s).
                            </p>
                        </div>
                        The assembly function <span class="bold">SVC_Handler</span> redirects to the C function <span class="bold">svc_dispatch</span> which then calls the corresponding syscall and then returns to the user session. 
                    </p>
                    <div class="illustration">
                        <div class="sub-illustration">
                            <img src="images/os_proj/os_alloc.JPG" alt="os_alloc">
                            <img src="images/os_proj/SVC_Handler.JPG" alt="svc_handler">
                        </div>
                        <img src="images/os_proj/svc_dispatch.JPG" alt="svc_dispatch">
                    </div>
                    <p>At this point, we are in the <span class="bold">Privileged Handler</span> mode. This mode can not be interrupted and is used to dispatch (svc_dispatch)
                        the syscall to the right process (regarding the svc number). Below, the argument n represents the svc number and the argument args[] points to the
                        <a href="#2.2">MSP</a> .

                    </p>
                </div>             
            </div>

            <div> <h2 id="tasks">2. Tasks</h2>

                <div> <h3 id="2.2">2.1 Definition and context</h3>
                    <p>A <span class="bold">task</span> is a code entity (generally a function) that runs independently from the main context. To function independently, it needs to have its own context, meaning that a task should
                        have a stack which would store its context (see illustrations below).
                        Therefore, we allocate memory for the task's <span class="bold">stack and members</span> (because it is a structure). Generally, the point of having multiple tasks is to have them, either run in parallel
                        or one after another <span class="bold">(Round Robin)</span>, each one being dedicated to a specific job (e.g., task).
                        Hence, we create a <span class="bold">list of tasks</span> which a variable <span class="bold">tsk_running</span> points to. This is a <span class="bold">circular double linked list</span>.
                        Each task points the previous running task and also to the next running one in the list.
                        In the pictures displayed below, we have an illustration of how a task is structured and a code example where <span class="bold">new_task</span> is created and added to the list of tasks.
                        <span class="bold">sp</span> and <span class="bold">splim</span> respectively point to the current task's stack pointer and the stack limit.
                    </p>
                    <div class="illustration-horiz-4">
                        <img src="images/os_proj/task_creation.JPG" alt="task_creation">
                        <img src="images/os_proj/task_creation(2).JPG" alt="task_creation">
                        <img src="images/os_proj/code_task_creation.JPG" alt="code_task_creation">
                        <img src="images/os_proj/task_creation_dbg.JPG" alt="task_creation_dbg">
                    </div>
                </div>

                <div><h3 id="2.2">2.2 Switching context</h3>
                    <p>When we start a program (in the main function), we are by default in the main context. But, in our case, we want to switch context to run multiple tasks (either concurrently or alternatively),
                        which have their <span class="bold">own context</span>. To do so, we need to trigger another exception, the <span class="bold">PendSV</span> exception. Again, the NVIC will branch the PC to the <span class="bold">PendSV_Handler</span> function in the OS kernel (svc.s).
                        This function does operate the context switching. It is in charge of saving the current running task's context (in its stack) and also to pop the next running task's context.
                        To specify that we want the current task's context to be saved and the next task's context to be popped, we need to make the <span class="bold">previous task pointer</span> point to the current task and 
                        the <span class="bold">task running pointer</span> point to the next running task.
                        The code at the most right below initiliazes the stack of the newly created task so that it has the minimum configurations to run.We start by setting <span class="bold">sp</span> and <span class="bold">splim</span>.
                        Then, we decrement our stack pointer of 18 (\( sizeof(uint32\_t) \)). Then, we initiliaze the minimum required registers for the task to run: <span class="bold">xPSR, PC, EXC_RETURN and CONTROL</span>. 
                        Switching context involves several steps:
                    </p>
                    <div class="illustration-horiz-3">
                        <img src="images/os_proj/switch_context.JPG" alt="switch_context">
                        <img src="images/os_proj/PendSV.JPG" alt="PendSV">
                        <img src="images/os_proj/code_task_creation_switch_context.JPG" alt="code_task_creation_switch_context">
                    </div>
                    <p>As a result, switching context involves</p>
                    <div class="frame-highlight">
                        <ol>
                            <li><span class="bold">Triggering the PendSV exception:</span> NVIC --> PendSV_Handler.</li>
                            <li><span class="bold">Saving the current context:</span> stack register values into the previous running task's stack.</li>
                            <li><span class="bold">Moving the PSP to the new task's stack:</span> pop the new running task's context.</li>
                            <li><span class="bold">Execution of the task:</span> the task is run until it gets interrupted by an event (preemption).</li>
                        </ol>
                    </div>
                </div>

                <div> <h3>2.3 Reentrance</h3>
                    <p>The <span class="bold">reentrance</span> consists in using the same function for different tasks. 
                        Though we create 3 tasks with the same function, the function is always context-dependent, meaning that function will run code using their own context.
                    </p>
                </div>

                <div> <h3>2.4 Task sleeping</h3>
                    <p>Among other features, we want to be able to make a task sleep for a given amount of time. During this sleeping period, the task leaves the lead to the next task it points to.
                        This sleeping task is then enqueued in a sleeping list. After some time, the task will be woken up and put back in the running list. 
                    </p>
                    <div class="illustration-horiz-2">
                        <img src="images/os_proj/task_sleeping.PNG" alt="task_sleeping">
                        <img src="images/os_proj/systick_cb.PNG" alt="systick_cb">
                    </div>
                    <p>Each time the Round Robin timer is triggered, we iterate through the task sleeping list and decrement each task's delay by the amount of time elapsed between each timeout callback.</p>
                </div>

                <div> <h3>2.5 Killing a task</h3>
                    <p>It may happen that a task terminates, meaning that it reached the end of the function's brackets. In this case, the task has to be <span class="bold">"killed"</span>. Otherwise, it will lead to an undefined behavior.
                        Therefore, just before a task finishes, we switch context so that other ready tasks can continue to operate. We create a syscall function <span class="bold">sys_task_kill</span> that does that for us.
                    </p>
                    <img style="width: 35%;" src="images/os_proj/task_kill.PNG" alt="task_kill">
                </div>
                
            </div>
            
            <div> <h2 id="semaphores">3. Semaphores</h2>
                <p>This is not aimed at explaining in-depth what are semaphores. A <span class="bold">semaphore</span> plays the role of a guardian. It uses a system of <span class="bold">tokens</span>
                    to control the access to a resource or a critical section (portion of code that should not be interrupted by other process). Like a <span class="bold">task</span>, a semaphore is a represented as a C structure,
                    which stores a <span class="bold">number of remaining tokens</span> and a <span class="bold">queue of waiting tasks</span>.
                </p>
                    <div class="illustration">
                        <img src="images/os_proj/sem_new.JPG" alt="sem_new">
                        <img src="images/os_proj/sem_p.JPG" alt="sem_p">
                        <img src="images/os_proj/sem_v.JPG" alt="sem_v">
                        <img src="images/os_proj/switch_ctx.JPG" alt="switch_ctx">
                    </div>
                <p>As soon as the semaphore receives a token <span class="bold">sys_sem_v</span>, the first task on the waiting queue is dequeued and placed directly in the running state.
                    This involves a context switching <span class="bold">sys_switch_ctx()</span>. This function simply sets a bit in a register that will trigger the PendSV exception.
                </p>
            </div>

            <div> <h2 id="peripherals">4. Accessing Peripherals</h2>
                <p>The <span class="bold">VFS (Virtual File System)</span> is an abstraction layer (part of oslib.h) that allows the user to manage all available peripherals with ease.
                    The VFS layer is part of the OS kernel. It sits between the <span class="bold">userspace</span> and the <span class="bold">real peripheral driver</span>.
                    Its job is to redirect syscalls like <span class="bold">open(), close(), etc.</span> to the right peripheral driver. Thus, this layer allows to manipulate all peripherals in the same way (i.e., using the same VFS functions).
                </p>
                <div class="frame-highlight">
                    <p>Let's take an example. Let's say we want to access a file on the SD card we plugged into the board and read its content. We will use
                        a syscall like <span class="bold">open($filepath$)</span> (the name is can be different). This open() syscall would then call the open()
                        (or equivalent function) of the <span class="bold">real file system</span> that manages the SD card memory.
                        If we wished to access another file on another peripheral, we would use the same syscall, but the VFS layer would redirect it to another file system responsible for this new device.
                        This mechanism is illustrated below.
                    </p>
                </div>
                <img style="width: 75%;" src="images/os_proj/vfs_hierarchy.PNG" alt="vfs_hierarchy">
                <div> <h3>Implementation</h3>
                    <p></p>
                </div>
            </div>

        </section> <!-- main-container -->

        <div id="footer"></div>

    </body>

</html>